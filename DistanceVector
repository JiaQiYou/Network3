#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>
#include <stdbool.h>

#define MAX_ROUTERS 26
#define INF INT_MAX

typedef struct {
    char name[10];
    int neighbors[MAX_ROUTERS], costs[MAX_ROUTERS], neighbor_count;
    int dist_table[MAX_ROUTERS][MAX_ROUTERS], min_costs[MAX_ROUTERS];
    int route_table[MAX_ROUTERS][2]; // [next_hop, cost]
    bool has_route[MAX_ROUTERS];
} Router;

Router routers[MAX_ROUTERS];
char names[MAX_ROUTERS][10];
int router_count = 0;

int find_router(const char* name) {
    for (int i = 0; i < router_count; i++)
        if (strcmp(names[i], name) == 0) return i;
    return -1;
}

void init_distance_table(int r) {
    for (int dest = 0; dest < router_count; dest++) {
        if (dest == r) continue;
        
        for (int via = 0; via < router_count; via++)
            routers[r].dist_table[dest][via] = INF;
            
        for (int n = 0; n < routers[r].neighbor_count; n++) {
            int neighbor = routers[r].neighbors[n];
            if (dest == neighbor)
                routers[r].dist_table[dest][neighbor] = routers[r].costs[n];
        }
        
        int min_cost = INF;
        for (int via = 0; via < router_count; via++)
            if (routers[r].dist_table[dest][via] < min_cost)
                min_cost = routers[r].dist_table[dest][via];
        routers[r].min_costs[dest] = min_cost;
    }
}

bool update_distance_table(int r, int neighbor, int* neighbor_dv) {
    int neighbor_cost = 0;
    bool is_neighbor = false;
    
    for (int n = 0; n < routers[r].neighbor_count; n++) {
        if (routers[r].neighbors[n] == neighbor) {
            neighbor_cost = routers[r].costs[n];
            is_neighbor = true;
            break;
        }
    }
    if (!is_neighbor) return false;
    
    bool changed = false;
    for (int dest = 0; dest < router_count; dest++) {
        if (dest == r) continue;
        
        int new_cost = (neighbor_dv[dest] == INF) ? INF : neighbor_cost + neighbor_dv[dest];
        int old_cost = routers[r].dist_table[dest][neighbor];
        
        routers[r].dist_table[dest][neighbor] = new_cost;
        if (new_cost != old_cost) changed = true;
        
        int old_min = routers[r].min_costs[dest];
        int new_min = INF;
        for (int via = 0; via < router_count; via++)
            if (routers[r].dist_table[dest][via] < new_min)
                new_min = routers[r].dist_table[dest][via];
        
        routers[r].min_costs[dest] = new_min;
        if (old_min != new_min) changed = true;
    }
    return changed;
}

void compute_routing_table(int r) {
    for (int dest = 0; dest < router_count; dest++) {
        if (dest == r) continue;
        
        int min_cost = INF, best_via = -1;
        
        // Sort neighbors by name for consistency
        int sorted[MAX_ROUTERS];
        for (int i = 0; i < routers[r].neighbor_count; i++)
            sorted[i] = routers[r].neighbors[i];
        
        for (int i = 0; i < routers[r].neighbor_count - 1; i++)
            for (int j = 0; j < routers[r].neighbor_count - i - 1; j++)
                if (strcmp(names[sorted[j]], names[sorted[j + 1]]) > 0) {
                    int temp = sorted[j];
                    sorted[j] = sorted[j + 1];
                    sorted[j + 1] = temp;
                }
        
        for (int n = 0; n < routers[r].neighbor_count; n++) {
            int via = sorted[n];
            if (routers[r].dist_table[dest][via] < min_cost) {
                min_cost = routers[r].dist_table[dest][via];
                best_via = via;
            }
        }
        
        if (best_via != -1 && min_cost < INF) {
            routers[r].route_table[dest][0] = best_via;
            routers[r].route_table[dest][1] = min_cost;
            routers[r].has_route[dest] = true;
        } else {
            routers[r].has_route[dest] = false;
        }
    }
}

void print_distance_table(int r, int step) {
    printf("Distance Table of router %s at t=%d:\n", routers[r].name, step);
    
    int destinations[MAX_ROUTERS], dest_count = 0;
    for (int i = 0; i < router_count; i++)
        if (i != r) destinations[dest_count++] = i;
    
    if (dest_count > 0) {
        printf("     ");
        for (int d = 0; d < dest_count; d++)
            printf("%s    ", names[destinations[d]]);
        printf("\n");
        
        for (int d = 0; d < dest_count; d++) {
            int dest = destinations[d];
            printf("%s    ", names[dest]);
            
            for (int other = 0; other < dest_count; other++) {
                int cost = routers[r].dist_table[dest][destinations[other]];
                printf("%-5s", (cost == INF) ? "INF" : "");
                if (cost != INF) printf("%-5d", cost);
            }
            printf("\n");
        }
    }
    printf("\n");
}

void print_routing_table(int r) {
    printf("Routing Table of router %s:\n", names[r]);
    for (int dest = 0; dest < router_count; dest++)
        if (dest != r && routers[r].has_route[dest])
            printf("%s,%s,%d\n", names[dest], 
                   names[routers[r].route_table[dest][0]], 
                   routers[r].route_table[dest][1]);
}

int main(int argc, char* argv[]) {
    FILE* input = (argc > 1) ? fopen(argv[1], "r") : stdin;
    if (!input && argc > 1) {
        fprintf(stderr, "Error opening file\n");
        return 1;
    }
    
    char line[256], r1[10], r2[10];
    int cost;
    
    // Read router names
    while (fgets(line, sizeof(line), input) && strcmp(line, "START\n") != 0) {
        line[strcspn(line, "\n")] = 0;
        if (strlen(line) > 0) {
            strcpy(names[router_count], line);
            strcpy(routers[router_count].name, line);
            routers[router_count].neighbor_count = 0;
            router_count++;
        }
    }
    
    // Read initial links
    while (fgets(line, sizeof(line), input) && strcmp(line, "UPDATE\n") != 0) {
        if (sscanf(line, "%s %s %d", r1, r2, &cost) == 3) {
            int r1_idx = find_router(r1), r2_idx = find_router(r2);
            
            routers[r1_idx].neighbors[routers[r1_idx].neighbor_count] = r2_idx;
            routers[r1_idx].costs[routers[r1_idx].neighbor_count++] = cost;
            
            routers[r2_idx].neighbors[routers[r2_idx].neighbor_count] = r1_idx;
            routers[r2_idx].costs[routers[r2_idx].neighbor_count++] = cost;
        }
    }
    
    // Read updates
    char updates[100][30]; // Store update lines
    int update_count = 0;
    while (fgets(line, sizeof(line), input) && strcmp(line, "END\n") != 0)
        if (strlen(line) > 1) strcpy(updates[update_count++], line);
    
    if (input != stdin) fclose(input);
    
    // Initialize distance tables
    for (int i = 0; i < router_count; i++)
        init_distance_table(i);
    
    // Initial convergence
    int step = 0;
    for (int i = 0; i < router_count; i++)
        print_distance_table(i, step);
    
    while (true) {
        int dvs[MAX_ROUTERS][MAX_ROUTERS];
        for (int i = 0; i < router_count; i++) {
            for (int j = 0; j < router_count; j++)
                dvs[i][j] = (i == j) ? 0 : routers[i].min_costs[j];
        }
        
        bool changed = false;
        for (int i = 0; i < router_count; i++)
            for (int n = 0; n < routers[i].neighbor_count; n++)
                if (update_distance_table(i, routers[i].neighbors[n], dvs[routers[i].neighbors[n]]))
                    changed = true;
        
        if (!changed) break;
        
        step++;
        for (int i = 0; i < router_count; i++) {
            compute_routing_table(i);
            print_distance_table(i, step);
        }
    }
    
    // Print routing tables
    for (int i = 0; i < router_count; i++) {
        print_routing_table(i);
        printf("\n");
    }
    
    // Handle topology updates
    if (update_count > 0) {
        int last_dvs[MAX_ROUTERS][MAX_ROUTERS];
        for (int i = 0; i < router_count; i++)
            for (int j = 0; j < router_count; j++)
                last_dvs[i][j] = (i == j) ? 0 : routers[i].min_costs[j];
        
        // Apply updates
        for (int u = 0; u < update_count; u++) {
            sscanf(updates[u], "%s %s %d", r1, r2, &cost);
            int r1_idx = find_router(r1), r2_idx = find_router(r2);
            
            if (cost == -1) {
                // Remove neighbors
                for (int n = 0; n < routers[r1_idx].neighbor_count; n++) {
                    if (routers[r1_idx].neighbors[n] == r2_idx) {
                        for (int j = n; j < routers[r1_idx].neighbor_count - 1; j++) {
                            routers[r1_idx].neighbors[j] = routers[r1_idx].neighbors[j + 1];
                            routers[r1_idx].costs[j] = routers[r1_idx].costs[j + 1];
                        }
                        routers[r1_idx].neighbor_count--;
                        break;
                    }
                }
                for (int n = 0; n < routers[r2_idx].neighbor_count; n++) {
                    if (routers[r2_idx].neighbors[n] == r1_idx) {
                        for (int j = n; j < routers[r2_idx].neighbor_count - 1; j++) {
                            routers[r2_idx].neighbors[j] = routers[r2_idx].neighbors[j + 1];
                            routers[r2_idx].costs[j] = routers[r2_idx].costs[j + 1];
                        }
                        routers[r2_idx].neighbor_count--;
                        break;
                    }
                }
                
                for (int dest = 0; dest < router_count; dest++) {
                    routers[r1_idx].dist_table[dest][r2_idx] = INF;
                    routers[r2_idx].dist_table[dest][r1_idx] = INF;
                }
            } else {
                // Add/update neighbors
                bool found1 = false, found2 = false;
                for (int n = 0; n < routers[r1_idx].neighbor_count; n++) {
                    if (routers[r1_idx].neighbors[n] == r2_idx) {
                        routers[r1_idx].costs[n] = cost;
                        found1 = true;
                        break;
                    }
                }
                if (!found1) {
                    routers[r1_idx].neighbors[routers[r1_idx].neighbor_count] = r2_idx;
                    routers[r1_idx].costs[routers[r1_idx].neighbor_count++] = cost;
                }
                
                for (int n = 0; n < routers[r2_idx].neighbor_count; n++) {
                    if (routers[r2_idx].neighbors[n] == r1_idx) {
                        routers[r2_idx].costs[n] = cost;
                        found2 = true;
                        break;
                    }
                }
                if (!found2) {
                    routers[r2_idx].neighbors[routers[r2_idx].neighbor_count] = r1_idx;
                    routers[r2_idx].costs[routers[r2_idx].neighbor_count++] = cost;
                }
                
                routers[r1_idx].dist_table[r2_idx][r2_idx] = cost;
                routers[r2_idx].dist_table[r1_idx][r1_idx] = cost;
            }
        }
        
        // Update with last DVs and converge again
        for (int i = 0; i < router_count; i++)
            for (int n = 0; n < routers[i].neighbor_count; n++)
                update_distance_table(i, routers[i].neighbors[n], last_dvs[routers[i].neighbors[n]]);
        
        for (int i = 0; i < router_count; i++)
            compute_routing_table(i);
        
        step++;
        for (int i = 0; i < router_count; i++)
            print_distance_table(i, step);
        
        // Final convergence
        while (true) {
            int dvs[MAX_ROUTERS][MAX_ROUTERS];
            for (int i = 0; i < router_count; i++)
                for (int j = 0; j < router_count; j++)
                    dvs[i][j] = (i == j) ? 0 : routers[i].min_costs[j];
            
            bool changed = false;
            for (int i = 0; i < router_count; i++)
                for (int n = 0; n < routers[i].neighbor_count; n++)
                    if (update_distance_table(i, routers[i].neighbors[n], dvs[routers[i].neighbors[n]]))
                        changed = true;
            
            if (!changed) break;
            
            step++;
            for (int i = 0; i < router_count; i++) {
                compute_routing_table(i);
                print_distance_table(i, step);
            }
        }
        
        for (int i = 0; i < router_count; i++) {
            print_routing_table(i);
            printf("\n");
        }
    }
    
    return 0;
}